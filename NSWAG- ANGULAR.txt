//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch, mergeMap, catchError } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf, throwError, of } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    // login(body?: LoginModel | undefined): Observable<void> {
    //     let url_ = this.baseUrl + "/api/Auth/login";
    //     url_ = url_.replace(/[?&]$/, "");

    //     const content_ = JSON.stringify(body);

    //     let options_ : any = {
    //         body: content_,
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Content-Type": "application/json",
    //         })
    //     };

    //     return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processLogin(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processLogin(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<void>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<void>;
    //     }));
    // }

    // protected processLogin(response: HttpResponseBase): Observable<void> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return _observableOf<void>(null as any);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<void>(null as any);
    // }
    login(body?: LoginModel): Observable<any> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");
    
        const content_ = JSON.stringify(body);
    
        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "json",  // נוודא שה-API מחזיר JSON ולא blob
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };
    
        return this.http.request("post", url_, options_).pipe(
            mergeMap((response_: any) => this.processLogin(response_))
        );
    }
    
    // protected processLogin(response: HttpResponseBase): Observable<any> {
    //     const status = response.status;
    //     const responseBody = response instanceof HttpResponse ? response.body : undefined;
    //     let _headers: any = {};
    //     if (response.headers) {
    //         for (let key of response.headers.keys()) {
    //             _headers[key] = response.headers.get(key);
    //         }
    //     }
    
    //     if (status === 200) {
    //         // החזרת טוקן מהתגובה
    //         return of(responseBody);  // החזרת תגובת ה-JSON הכוללת את הטוקן
    //     } else if (status !== 200 && status !== 204) {
    //         return this.blobToText(responseBody).pipe(
    //             mergeMap(_responseText => {
    //                 return throwError('An unexpected server error occurred.');
    //             })
    //         );
    //     }
    
    //     return of(null);
    // }
    private blobToText(blob: Blob): Observable<string> {
        return new Observable(observer => {
            const reader = new FileReader();
            
            reader.onloadend = () => {
                observer.next(reader.result as string);
                observer.complete();
            };
            
            reader.onerror = (error) => {
                observer.error(error);
            };
            
            reader.readAsText(blob);
        });
    }
    // protected processLogin(response: HttpResponseBase): Observable<any> {
    //     const status = response.status;
    //     const responseBody = response instanceof HttpResponse ? response.body : undefined;
    //     let _headers: any = {};
        
    //     if (response.headers) {
    //         for (let key of response.headers.keys()) {
    //             _headers[key] = response.headers.get(key);
    //         }
    //     }
    
    //     if (status === 200) {
    //         // המרת ה-Blob למידע טקסטואלי (למשל JSON)
    //         return this.blobToText(responseBody).pipe(
    //             mergeMap((responseText: string) => {
    //                 try {
    //                     const responseJson = JSON.parse(responseText);  // פרס את התגובה ל-JSON
    //                     return of(responseJson);  // החזר את המידע כ-Observable
    //                 } catch (error) {
    //                     return throwError('Failed to parse response JSON');
    //                 }
    //             })
    //         );
    //     } else if (status !== 200 && status !== 204) {
    //         return this.blobToText(responseBody).pipe(
    //             mergeMap(_responseText => {
    //                 return throwError('An unexpected server error occurred.');
    //             })
    //         );
    //     }
    
    //     return of(null);
    // }
    protected processLogin(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBody = response instanceof HttpResponse ? response.body : undefined;
        let _headers: any = {};
    
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            // אין צורך להמיר את התגובה, היא כבר JSON
            return of(responseBody);
        } else if (status !== 200 && status !== 204) {
            // תוכל להוסיף טיפול בשגיאה לפי הצורך
            return throwError(() => new Error('An unexpected server error occurred.'));
        }
    
        return of(null);
    }
    
    /**
     * @param body (optional) 
     * @return OK
     */
    register(body?: RegisterModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    // lecturerAll(): Observable<Lecturer[]> {
    //     let url_ = this.baseUrl + "/api/Lecturer";
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processLecturerAll(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processLecturerAll(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<Lecturer[]>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<Lecturer[]>;
    //     }));
    // }

    // protected processLecturerAll(response: HttpResponseBase): Observable<Lecturer[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         if (Array.isArray(resultData200)) {
    //             result200 = [] as any;
    //             for (let item of resultData200)
    //                 result200!.push(Lecturer.fromJS(item));
    //         }
    //         else {
    //             result200 = <any>null;
    //         }
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<Lecturer[]>(null as any);
    // }


    /**
 * @return OK
 */
lecturerAll(): Observable<Lecturer[]> {
    let url_ = this.baseUrl + "/api/Lecturer";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
            "Accept": "text/plain"
        })
    };

    return this.http.request("get", url_, options_).pipe(
        _observableMergeMap((response_: any) => {
            return this.processLecturerAll(response_);
        }),
        _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLecturerAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lecturer[]>;
                }
            } else {
                return _observableThrow(response_) as any as Observable<Lecturer[]>;
            }
        })
    );
}

protected processLecturerAll(response: HttpResponseBase): Observable<Lecturer[]> {
    const status = response.status;
    const responseBlob =
        response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
        for (let key of response.headers.keys()) {
            _headers[key] = response.headers.get(key);
        }
    }

    if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            const resultData = _responseText ? JSON.parse(_responseText) : [];
            const result: Lecturer[] = resultData.map((item: any) => Lecturer.fromJS(item));
            return _observableOf(result);
        }));
    } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
    }

    return _observableOf<Lecturer[]>([]);
}

    /**
     * @param body (optional) 
     * @return OK
     */
    lecturerPOST(body?: LecturerDTO | undefined): Observable<Lecturer> {
        let url_ = this.baseUrl + "/api/Lecturer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLecturerPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLecturerPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lecturer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Lecturer>;
        }));
    }

    protected processLecturerPOST(response: HttpResponseBase): Observable<Lecturer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Lecturer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lecturer>(null as any);
    }

    /**
     * @return OK
     */
    id(lecturerId: number): Observable<Lecturer> {
        let url_ = this.baseUrl + "/api/Lecturer/id/{LecturerId}";
        if (lecturerId === undefined || lecturerId === null)
            throw new Error("The parameter 'lecturerId' must be defined.");
        url_ = url_.replace("{LecturerId}", encodeURIComponent("" + lecturerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lecturer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Lecturer>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<Lecturer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Lecturer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lecturer>(null as any);
    }

    /**
     * @return OK
     */
    // name(lecturerName: string): Observable<Lecturer[]> {
    //     let url_ = this.baseUrl + "/api/Lecturer/name/{LecturerName}";
    //     if (lecturerName === undefined || lecturerName === null)
    //         throw new Error("The parameter 'lecturerName' must be defined.");
    //     url_ = url_.replace("{LecturerName}", encodeURIComponent("" + lecturerName));
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processName(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processName(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<Lecturer[]>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<Lecturer[]>;
    //     }));
    // }

    // protected processName(response: HttpResponseBase): Observable<Lecturer[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         if (Array.isArray(resultData200)) {
    //             result200 = [] as any;
    //             for (let item of resultData200)
    //                 result200!.push(Lecturer.fromJS(item));
    //         }
    //         else {
    //             result200 = <any>null;
    //         }
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<Lecturer[]>(null as any);
    // }
    name(lecturerName: string): Observable<Lecturer[]> {
        let url_ = this.baseUrl + "/api/Lecturer/name/{LecturerName}";
        if (lecturerName === undefined || lecturerName === null)
            throw new Error("The parameter 'lecturerName' must be defined.");
        url_ = url_.replace("{LecturerName}", encodeURIComponent("" + lecturerName));
        url_ = url_.replace(/[?&]$/, "");
    
        let options_: any = {
            observe: "response",
            responseType: "json", // שינויים כאן, משתמש ב-JSON
            headers: new HttpHeaders({
                "Accept": "application/json" // מבקש JSON מהשרת
            })
        };
    
        return this.http.request("get", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return this.processName(response_);
            })
        ).pipe(
            _observableCatch((response_: any) => {
                if (response_ instanceof HttpResponseBase) {
                    try {
                        return this.processName(response_ as any);
                    } catch (e) {
                        return _observableThrow(e) as any as Observable<Lecturer[]>;
                    }
                } else
                    return _observableThrow(response_) as any as Observable<Lecturer[]>;
            })
        );
    }
    
    protected processName(response: HttpResponseBase): Observable<Lecturer[]> {
        const status = response.status;
        const responseBody = response instanceof HttpResponse ? response.body : undefined;
    
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            if (responseBody) {
                try {
                    let result200: Lecturer[] = [];
                    if (Array.isArray(responseBody)) {
                        result200 = responseBody.map((item: any) => Lecturer.fromJS(item));
                    }
                    return _observableOf(result200);
                } catch (e) {
                    return _observableThrow("Error parsing response data.") as any as Observable<Lecturer[]>;
                }
            }
        } else if (status !== 200 && status !== 204) {
            return _observableThrow("An unexpected server error occurred.") as any as Observable<Lecturer[]>;
        }
    
        return _observableOf<Lecturer[]>([]);
    }
    
    /**
     * @param body (optional) 
     * @return OK
     */
    lecturerPUT(lecturerId: number, body?: LecturerDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Lecturer/{LecturerId}";
        if (lecturerId === undefined || lecturerId === null)
            throw new Error("The parameter 'lecturerId' must be defined.");
        url_ = url_.replace("{LecturerId}", encodeURIComponent("" + lecturerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLecturerPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLecturerPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLecturerPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    lecturerDELETE(lecturerId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Lecturer/{LecturerId}";
        if (lecturerId === undefined || lecturerId === null)
            throw new Error("The parameter 'lecturerId' must be defined.");
        url_ = url_.replace("{LecturerId}", encodeURIComponent("" + lecturerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLecturerDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLecturerDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLecturerDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    // lessonAll(): Observable<Lesson[]> {
    //     let url_ = this.baseUrl + "/api/Lesson";
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processLessonAll(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processLessonAll(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<Lesson[]>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<Lesson[]>;
    //     }));
    // }

    // protected processLessonAll(response: HttpResponseBase): Observable<Lesson[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         if (Array.isArray(resultData200)) {
    //             result200 = [] as any;
    //             for (let item of resultData200)
    //                 result200!.push(Lesson.fromJS(item));
    //         }
    //         else {
    //             result200 = <any>null;
    //         }
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<Lesson[]>(null as any);
    // }
    lessonAll(): Observable<Lesson[]> {
        let url_ = this.baseUrl + "/api/Lesson";
        url_ = url_.replace(/[?&]$/, "");
    
        let options_: any = {
            observe: "response",
            responseType: "json", // שינוי ל-JSON במקום blob
            headers: new HttpHeaders({
                "Accept": "application/json" // מבקש JSON
            })
        };
    
        return this.http.request("get", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return this.processLessonAll(response_);
            })
        ).pipe(
            _observableCatch((response_: any) => {
                if (response_ instanceof HttpResponseBase) {
                    try {
                        return this.processLessonAll(response_ as any);
                    } catch (e) {
                        return _observableThrow(e) as any as Observable<Lesson[]>;
                    }
                } else
                    return _observableThrow(response_) as any as Observable<Lesson[]>;
            })
        );
    }
    
    protected processLessonAll(response: HttpResponseBase): Observable<Lesson[]> {
        const status = response.status;
        const responseBody = response instanceof HttpResponse ? response.body : undefined;
    
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            if (responseBody) {
                try {
                    let result200: Lesson[] = [];
                    if (Array.isArray(responseBody)) {
                        result200 = responseBody.map((item: any) => Lesson.fromJS(item));
                    }
                    return _observableOf(result200);
                } catch (e) {
                    return _observableThrow("Error parsing response data.") as any as Observable<Lesson[]>;
                }
            }
        } else if (status !== 200 && status !== 204) {
            return _observableThrow("An unexpected server error occurred.") as any as Observable<Lesson[]>;
        }
    
        return _observableOf<Lesson[]>([]);
    }
    
    /**
     * @param body (optional) 
     * @return OK
     */
    // lessonPOST(body?: LessonDTO | undefined): Observable<Lesson[]> {
    //     let url_ = this.baseUrl + "/api/Lesson";
    //     url_ = url_.replace(/[?&]$/, "");

    //     const content_ = JSON.stringify(body);

    //     let options_ : any = {
    //         body: content_,
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Content-Type": "application/json",
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processLessonPOST(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processLessonPOST(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<Lesson>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<Lesson>;
    //     }));
    // }

    // protected processLessonPOST(response: HttpResponseBase): Observable<Lesson> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         result200 = Lesson.fromJS(resultData200);
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<Lesson[]>([]);
    // }
    lessonPOST(body?: LessonDTO): Observable<Lesson[]> {
        let url_ = this.baseUrl + "/api/Lesson";
        url_ = url_.replace(/[?&]$/, "");
    
        const content_ = JSON.stringify(body);
    
        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "json", // שינוי ל-JSON במקום blob
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json" // מבקש JSON בתשובה
            })
        };
    
        return this.http.request("post", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return this.processLessonPOST(response_);
            })
        ).pipe(
            _observableCatch((response_: any) => {
                if (response_ instanceof HttpResponseBase) {
                    try {
                        return this.processLessonPOST(response_ as any);
                    } catch (e) {
                        return _observableThrow(e) as any as Observable<Lesson[]>;
                    }
                } else
                    return _observableThrow(response_) as any as Observable<Lesson[]>;
            })
        );
    }
    
    protected processLessonPOST(response: HttpResponseBase): Observable<Lesson[]> {
        const status = response.status;
        const responseBody = response instanceof HttpResponse ? response.body : undefined;
    
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            if (responseBody) {
                try {
                    let result200: Lesson[] = [];
                    if (Array.isArray(responseBody)) {
                        result200 = responseBody.map((item: any) => Lesson.fromJS(item));
                    }
                    return _observableOf(result200);
                } catch (e) {
                    return _observableThrow("Error parsing response data.") as any as Observable<Lesson[]>;
                }
            }
        } else if (status !== 200 && status !== 204) {
            return _observableThrow("An unexpected server error occurred.") as any as Observable<Lesson[]>;
        }
    
        return _observableOf<Lesson[]>([]);
    }
    
    /**
     * @return OK
     */
    // title(): Observable<string[]> {
    //     let url_ = this.baseUrl + "/api/Lesson/title";
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processTitle(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processTitle(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<string[]>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<string[]>;
    //     }));
    // }

    // protected processTitle(response: HttpResponseBase): Observable<string[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         if (Array.isArray(resultData200)) {
    //             result200 = [] as any;
    //             for (let item of resultData200)
    //                 result200!.push(item);
    //         }
    //         else {
    //             result200 = <any>null;
    //         }
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<string[]>(null as any);
    // }
    title(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Lesson/title";
        url_ = url_.replace(/[?&]$/, "");
    
        let options_: any = {
            observe: "response",
            responseType: "json", // שינוי ל-JSON במקום blob
            headers: new HttpHeaders({
                "Accept": "application/json" // מבקש JSON בתשובה
            })
        };
    
        return this.http.request("get", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return this.processTitle(response_);
            })
        ).pipe(
            _observableCatch((response_: any) => {
                if (response_ instanceof HttpResponseBase) {
                    try {
                        return this.processTitle(response_ as any);
                    } catch (e) {
                        return _observableThrow(e) as any as Observable<string[]>;
                    }
                } else
                    return _observableThrow(response_) as any as Observable<string[]>;
            })
        );
    }
    
    protected processTitle(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBody = response instanceof HttpResponse ? response.body : undefined;
    
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            if (responseBody) {
                try {
                    let result200: string[] = [];
                    if (Array.isArray(responseBody)) {
                        result200 = responseBody;
                    }
                    return _observableOf(result200);
                } catch (e) {
                    return _observableThrow("Error parsing response data.") as any as Observable<string[]>;
                }
            }
        } else if (status !== 200 && status !== 204) {
            return _observableThrow("An unexpected server error occurred.") as any as Observable<string[]>;
        }
    
        return _observableOf<string[]>([]);
    }
    
    /**
     * @return OK
     */
    id2(id: number): Observable<Lesson> {
        let url_ = this.baseUrl + "/api/Lesson/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lesson>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Lesson>;
        }));
    }

    protected processId2(response: HttpResponseBase): Observable<Lesson> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Lesson.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lesson>(null as any);
    }

    /**
     * @return OK
     */
    title2(title: string): Observable<Lesson[]> {
        let url_ = this.baseUrl + "/api/Lesson/title/{title}";
        if (title === undefined || title === null)
            throw new Error("The parameter 'title' must be defined.");
        url_ = url_.replace("{title}", encodeURIComponent("" + title));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTitle2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTitle2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lesson[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Lesson[]>;
        }));
    }

    protected processTitle2(response: HttpResponseBase): Observable<Lesson[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lesson.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lesson[]>([]);
    }
   
    /**
     * @return OK
     */
    name2(name: string): Observable<Lesson[]> {
        let url_ = this.baseUrl + "/api/Lesson/name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processName2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processName2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Lesson[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Lesson[]>;
        }));
    }

    protected processName2(response: HttpResponseBase): Observable<Lesson[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Lesson.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lesson[]>([]);
    }
    
    /**
     * @param body (optional) 
     * @return OK
     */
    lessonPUT(id: number, body?: LessonDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Lesson/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLessonPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLessonPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLessonPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    lessonDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Lesson/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLessonDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLessonDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLessonDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    upload(file?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/S3/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    // download(fileName: string): Observable<Blob> {
    //     let url_ = this.baseUrl + "/api/S3/download/{fileName}";
    //     if (fileName === undefined || fileName === null)
    //         throw new Error("The parameter 'fileName' must be defined.");
    //     url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processDownload(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processDownload(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<Blob>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<Blob>;
    //     }));
    // }
    download(fileName: string): Observable<Blob> {
        let url_ = this.baseUrl + "/api/S3/download/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");
    
        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };
    
        return this.http.request("get", url_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return this.processDownload(response_);
            })
        ).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Blob>; // שינוי כאן ל-Observable<Blob>
                }
            } else
                return _observableThrow(response_) as any as Observable<Blob>; // שינוי כאן ל-Observable<Blob>
        }));
    }
    
    protected processDownload(response: HttpResponseBase): Observable<Blob> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;
    
        let _headers: any = {}; 
        if (response.headers) { 
            for (let key of response.headers.keys()) { 
                _headers[key] = response.headers.get(key); 
            }
        }
    
        if (status === 200) {
            return _observableOf(responseBlob as Blob); // שינוי כאן להחזיר Blob
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Blob>(null as any); // שינוי כאן להחזיר Blob
    }
    
    // protected processDownload(response: HttpResponseBase): Observable<void> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return _observableOf<void>(null as any);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<void>(null as any);
    // }
    // protected processDownload(response: HttpResponseBase): Observable<void> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;
    
    //     let _headers: any = {};
    //     if (response.headers) {
    //         for (let key of response.headers.keys()) {
    //             _headers[key] = response.headers.get(key);
    //         }
    //     }
    
    //     if (status === 200 && responseBlob) {
    //         const contentDisposition = response.headers?.get('content-disposition');
    //         let fileName = 'downloaded-file';
    //         if (contentDisposition) {
    //             const match = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
    //             if (match && match[1]) {
    //                 fileName = match[1].replace(/['"]/g, '');
    //             }
    //         }
    
    //         const blobUrl = URL.createObjectURL(responseBlob);
    //         const a = document.createElement('a');
    //         a.href = blobUrl;
    //         a.download = fileName;
    //         document.body.appendChild(a);
    //         a.click();
    //         document.body.removeChild(a);
    //         URL.revokeObjectURL(blobUrl);
    
    //         return _observableOf<void>(null as any);
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<void>(null as any);
    // }
    
    /**
     * @return OK
     */
    files(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/S3/files";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiles(response_);
        })).pipe(_observableCatch((response_: string[]) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    // protected processFiles(response: HttpResponseBase): Observable<string[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return _observableOf<string[]>([]);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<string[]>([]);
    // }
    protected processFiles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;
    
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
    
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    const result = _responseText ? JSON.parse(_responseText) : [];
                    return _observableOf(result);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                })
            );
        }
        return _observableOf<string[]>([]);
    }
    
    /**
     * @return OK
     */
    delete(fileName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/S3/delete/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    // userAll(): Observable<User[]> {
    //     let url_ = this.baseUrl + "/api/User";
    //     url_ = url_.replace(/[?&]$/, "");

    //     let options_ : any = {
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Accept": "text/plain"
    //         })
    //     };

    //     return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
    //         return this.processUserAll(response_);
    //     })).pipe(_observableCatch((response_: any) => {
    //         if (response_ instanceof HttpResponseBase) {
    //             try {
    //                 return this.processUserAll(response_ as any);
    //             } catch (e) {
    //                 return _observableThrow(e) as any as Observable<User[]>;
    //             }
    //         } else
    //             return _observableThrow(response_) as any as Observable<User[]>;
    //     }));
    // }

    // protected processUserAll(response: HttpResponseBase): Observable<User[]> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (response as any).error instanceof Blob ? (response as any).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         if (Array.isArray(resultData200)) {
    //             result200 = [] as any;
    //             for (let item of resultData200)
    //                 result200!.push(User.fromJS(item));
    //         }
    //         else {
    //             result200 = <any>null;
    //         }
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<User[]>(null as any);
    // }

    userAll(): Observable<User[]> {
        const url = this.baseUrl + "/api/User";
    
        return this.http.get<User[]>(url).pipe(
            catchError((error: any) => {
                console.error("Error fetching users", error);
                return throwError(() => new Error("Failed to load users"));
            })
        );
    }
    
     protected processUserAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>([]);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userPOST(body?: UserDTO | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUserPOST(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @return OK
     */
    userGET(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUserGET(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userPUT(id: number, body?: UserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    userDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class Lecturer implements ILecturer {
    lecturerId?: number;
    lecturerName?: string | undefined;
    lecturerLessons?: Lesson[] | undefined;

    constructor(data?: ILecturer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lecturerId = _data["lecturerId"];
            this.lecturerName = _data["lecturerName"];
            if (Array.isArray(_data["lecturerLessons"])) {
                this.lecturerLessons = [] as any;
                for (let item of _data["lecturerLessons"])
                    this.lecturerLessons!.push(Lesson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Lecturer {
        data = typeof data === 'object' ? data : {};
        let result = new Lecturer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lecturerId"] = this.lecturerId;
        data["lecturerName"] = this.lecturerName;
        if (Array.isArray(this.lecturerLessons)) {
            data["lecturerLessons"] = [];
            for (let item of this.lecturerLessons)
                data["lecturerLessons"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILecturer {
    lecturerId?: number;
    lecturerName?: string | undefined;
    lecturerLessons?: Lesson[] | undefined;
}

export class LecturerDTO implements ILecturerDTO {
    lecturerName?: string | undefined;

    constructor(data?: ILecturerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lecturerName = _data["lecturerName"];
        }
    }

    static fromJS(data: any): LecturerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LecturerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lecturerName"] = this.lecturerName;
        return data;
    }
}

export interface ILecturerDTO {
    lecturerName?: string | undefined;
}

export class Lesson implements ILesson {
    lessonId?: number;
    lessonName?: string | undefined;
    lessonTitle?: string | undefined;
    lessonDuration?: string;
    lessonReleaseDate?: string;
    lessonListenersCount?: number;
    lessonDownloadCount?: number;
    lessonUrl?: string | undefined;
    lessonLecturerId?: number;
    lessonLecturer?: Lecturer;
    lessonUsers?: User[] | undefined;

    constructor(data?: ILesson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lessonId = _data["lessonId"];
            this.lessonName = _data["lessonName"];
            this.lessonTitle = _data["lessonTitle"];
            this.lessonDuration = _data["lessonDuration"];
            this.lessonReleaseDate = _data["lessonReleaseDate"];
            this.lessonListenersCount = _data["lessonListenersCount"];
            this.lessonDownloadCount = _data["lessonDownloadCount"];
            this.lessonUrl = _data["lessonUrl"];
            this.lessonLecturerId = _data["lessonLecturerId"];
            this.lessonLecturer = _data["lessonLecturer"] ? Lecturer.fromJS(_data["lessonLecturer"]) : <any>undefined;
            if (Array.isArray(_data["lessonUsers"])) {
                this.lessonUsers = [] as any;
                for (let item of _data["lessonUsers"])
                    this.lessonUsers!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Lesson {
        data = typeof data === 'object' ? data : {};
        let result = new Lesson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lessonId"] = this.lessonId;
        data["lessonName"] = this.lessonName;
        data["lessonTitle"] = this.lessonTitle;
        data["lessonDuration"] = this.lessonDuration;
        data["lessonReleaseDate"] = this.lessonReleaseDate;
        data["lessonListenersCount"] = this.lessonListenersCount;
        data["lessonDownloadCount"] = this.lessonDownloadCount;
        data["lessonUrl"] = this.lessonUrl;
        data["lessonLecturerId"] = this.lessonLecturerId;
        data["lessonLecturer"] = this.lessonLecturer ? this.lessonLecturer.toJSON() : <any>undefined;
        if (Array.isArray(this.lessonUsers)) {
            data["lessonUsers"] = [];
            for (let item of this.lessonUsers)
                data["lessonUsers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILesson {
    lessonId?: number;
    lessonName?: string | undefined;
    lessonTitle?: string | undefined;
    lessonDuration?: string;
    lessonReleaseDate?: string;
    lessonListenersCount?: number;
    lessonDownloadCount?: number;
    lessonUrl?: string | undefined;
    lessonLecturerId?: number;
    lessonLecturer?: Lecturer;
    lessonUsers?: User[] | undefined;
}

export class LessonDTO implements ILessonDTO {
    lessonName?: string | undefined;
    lessonTitle?: string | undefined;
    lessonDuration?: string;
    lessonRealeaseDate?: string;
    lessonUrl?: string | undefined;
    lessonLecturerId?: number;

    constructor(data?: ILessonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lessonName = _data["lessonName"];
            this.lessonTitle = _data["lessonTitle"];
            this.lessonDuration = _data["lessonDuration"];
            this.lessonRealeaseDate = _data["lessonRealeaseDate"];
            this.lessonUrl = _data["lessonUrl"];
            this.lessonLecturerId = _data["lessonLecturerId"];
        }
    }

    static fromJS(data: any): LessonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LessonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lessonName"] = this.lessonName;
        data["lessonTitle"] = this.lessonTitle;
        data["lessonDuration"] = this.lessonDuration;
        data["lessonRealeaseDate"] = this.lessonRealeaseDate;
        data["lessonUrl"] = this.lessonUrl;
        data["lessonLecturerId"] = this.lessonLecturerId;
        return data;
    }
}

export interface ILessonDTO {
    lessonName?: string | undefined;
    lessonTitle?: string | undefined;
    lessonDuration?: string;
    lessonRealeaseDate?: string;
    lessonUrl?: string | undefined;
    lessonLecturerId?: number;
}

export class LoginModel implements ILoginModel {
    userName?: string | undefined;
    userPassword?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userPassword = _data["userPassword"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userPassword"] = this.userPassword;
        return data;
    }
}

export interface ILoginModel {
    userName?: string | undefined;
    userPassword?: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    userName?: string | undefined;
    userPassword?: string | undefined;
    userEmail?: string | undefined;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userPassword = _data["userPassword"];
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userPassword"] = this.userPassword;
        data["userEmail"] = this.userEmail;
        return data;
    }
}

export interface IRegisterModel {
    userName?: string | undefined;
    userPassword?: string | undefined;
    userEmail?: string | undefined;
}

export class User implements IUser {
    userId?: number;
    userName?: string | undefined;
    userEmail?: string | undefined;
    userPassword?: string | undefined;
    userRole?: string | undefined;
    userLessons?: Lesson[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userEmail = _data["userEmail"];
            this.userPassword = _data["userPassword"];
            this.userRole = _data["userRole"];
            if (Array.isArray(_data["userLessons"])) {
                this.userLessons = [] as any;
                for (let item of _data["userLessons"])
                    this.userLessons!.push(Lesson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userEmail"] = this.userEmail;
        data["userPassword"] = this.userPassword;
        data["userRole"] = this.userRole;
        if (Array.isArray(this.userLessons)) {
            data["userLessons"] = [];
            for (let item of this.userLessons)
                data["userLessons"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    userId?: number;
    userName?: string | undefined;
    userEmail?: string | undefined;
    userPassword?: string | undefined;
    userRole?: string | undefined;
    userLessons?: Lesson[] | undefined;
}

export class UserDTO implements IUserDTO {
    userId?: number;
    userName?: string | undefined;
    userEmail?: string | undefined;
    userPassword?: string | undefined;
    userRole?: string | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userEmail = _data["userEmail"];
            this.userPassword = _data["userPassword"];
            this.userRole = _data["userRole"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userEmail"] = this.userEmail;
        data["userPassword"] = this.userPassword;
        data["userRole"] = this.userRole;
        return data;
    }
}

export interface IUserDTO {
    userId?: number;
    userName?: string | undefined;
    userEmail?: string | undefined;
    userPassword?: string | undefined;
    userRole?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}